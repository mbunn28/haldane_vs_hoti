#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jul 12 15:48:31 2019

@author: sdiop
"""


import matplotlib
import numpy as np
import matplotlib.pyplot as plt
from math import pi
from math import sqrt
import os
from matplotlib.patches import Circle
from matplotlib.collections import PatchCollection



N = 6
a= 1


PBC_i = True
PBC_j = False
Haldane = True
Semenoff = False
Corners = True

def lat(i,j,s): return(6*N*i+6*j+s)  #lattice mapping

def find_mode(eigenvalues, m): # finds the index mode which energy is closest to E
    abs = np.unique(np.round(np.abs(eigenvalues),4))
    absenergies = np.round(np.abs(eigenvalues),4)
    index = [i for i, e in enumerate(absenergies) if e == abs[m]]
    return(index)

def pos(i,j,s): # Gives the x,y coordinates of site i,j,s
    A = np.array([sqrt(3)/2 , -1/2])
    B = np.array([-sqrt(3)/2, -1/2])
    C = np.array([0,1])
    cell =  (i*C + j*A)*3
    if s==0: return(cell+C)
    if s==1: return(cell+A+C)
    if s==2: return(cell+A)
    if s==3: return(cell+A+B)
    if s==4: return(cell+B)
    if s==5: return(cell+B+C)

def initialize_hamiltonian(t0, t1, t2, t3, M):
    vv = 1000
    Nvv = 0
    h = np.zeros((6*N**2,6*N**2), dtype = complex)

    for i in range(N):
        for j in range(N):

            h[lat(i,j,0), lat(i,j,1)] = -t0
            h[lat(i,j,0), lat(i,j,5)] = -t0
            h[lat(i,j,0), lat((i+1)%N,j,3)] = -t1

            h[lat(i,j,2), lat(i,j,1)] = -t0
            h[lat(i,j,2), lat(i,j,3)] = -t0
            h[lat(i,j,2), lat(i,(j+1)%N,5)] = -t1

            h[lat(i,j,4), lat(i,j,3)] = -t0
            h[lat(i,j,4), lat(i,j,5)] = -t0
            h[lat(i,j,4), lat((i-1)%N,(j-1)%N,1)] = -t1

            if Haldane == True:

                h[lat(i,j,0), lat(i,j,4)] = -a*1j*t2
                h[lat(i,j,0), lat((i+1)%N,j,4)] = -a*1j*t3
                h[lat(i,j,0), lat((i+1)%N,(j+1)%N,4)] = -a*1j*t3

                h[lat(i,j,1), lat(i,j,5)] = -a*1j*t2
                h[lat(i,j,1), lat((i+1)%N,(j+1)%N,5)] = -a*1j*t3
                h[lat(i,j,1), lat(i,(j+1)%N,5)] = -a*1j*t3

                h[lat(i,j,2), lat(i,j,0)] = -a*1j*t2
                h[lat(i,j,2), lat(i,(j+1)%N,0)] = -a*1j*t3
                h[lat(i,j,2), lat((i-1)%N,j,0)] = -a*1j*t3

                h[lat(i,j,3), lat(i,j,1)] = -a*1j*t2
                h[lat(i,j,3), lat((i-1)%N,j,1)] = -a*1j*t3
                h[lat(i,j,3), lat((i-1)%N,(j-1)%N,1)] = -a*1j*t3

                h[lat(i,j,4), lat(i,j,2)] = -a*1j*t2
                h[lat(i,j,4), lat((i-1)%N,(j-1)%N,2)] = -a*1j*t3
                h[lat(i,j,4), lat(i,(j-1)%N,2)] = -a*1j*t3

                h[lat(i,j,5), lat(i,j,3)] = -a*1j*t2
                h[lat(i,j,5), lat(i,(j-1)%N,3)] = -a*1j*t3
                h[lat(i,j,5), lat((i+1)%N,j,3)] = -a*1j*t3

            if Semenoff == True:
                for s in [0,2,4]:
                    h[lat(i,j,s), lat(i,j,s)] = +M
                for s in [1,3,5]:
                    h[lat(i,j,s), lat(i,j,s)] = -M

    if PBC_i == False:
        for j in range(N):
           h[lat(N-1,j,0), lat(0,j,3)] = 0
           h[lat(0,j,4), lat(N-1,(j-1)%N,1)] = 0

           h[lat(0,(j+1)%N,3), lat(N-1,j,1)] = 0
           h[lat(N-1,j,0), lat(0,j,4)] = 0
           h[lat(0,(j+1)%N,4), lat(N-1,j,2)] = 0
           h[lat(N-1,j,5), lat(0,j,3)] = 0

           h[lat(N-1,j,1), lat(0,(j+1)%N,5)] = 0
           h[lat(N-1,j,0), lat(0,(j+1)%N,4)] = 0
           h[lat(0,j,3), lat(N-1,j,1)] = 0
           h[lat(0,j,2), lat(N-1,j,0)] = 0

           # #dimer geometry
           # h[lat(N-1, j, 2),lat(N-1, j, 1)] = 0
           # h[lat(N-1, j, 0),lat(N-1, j, 5)] = 0
           #
           # h[lat(N-1,j,0), lat(N-1,j,4)] = 0
           # h[lat(N-1,j,2), lat(N-1,j,0)] = 0
           # h[lat(N-1,j,1), lat(N-1,j,5)] = 0
           # h[lat(N-1,j,3), lat(N-1,j,1)] = 0
           #
           # h[lat(N-1,j,2), lat(N-1,(j+1)%N,0)] = 0
           # h[lat(N-1,j,1), lat(N-1,(j+1)%N,5)] = 0
           # h[lat(N-1,j,5), lat(0,j,3)] = 0
           # h[lat(0,j,4), lat(N-1,(j-1)%N,2)] = 0

    if PBC_j == False:
        for i in range(N):
            h[lat(i,N-1,2), lat(i,0,5)] = 0
            h[lat(i,0,4), lat((i-1)%N,N-1,1)] = 0

            h[lat((i+1)%N,0,3), lat(i,N-1,1)] = 0
            h[lat(i,N-1,1), lat(i,0,5)] = 0
            h[lat((i+1)%N,0,4), lat(i,N-1,2)] = 0
            h[lat(i,N-1,2), lat(i,0,0)] = 0

            h[lat(i,N-1,1), lat((i+1)%N,0,5)] = 0
            h[lat(i,0,5), lat(i,N-1,3)] = 0
            h[lat(i,N-1,0), lat((i+1)%N,0,4)] = 0
            h[lat(i,0,4), lat(i,N-1,2)] = 0

    # #dimer geometry
    if PBC_j == False and Corners == True:
        for i in range(0,N):
            for s in [0,3,4,5]:
                h[lat(i,0,s),lat(i,0,s)] = vv
                Nvv += 1
            for s in [0,1,2,3]:
                h[lat(i,N-1,s),lat(i,N-1,s)] = vv
                Nvv += 1

    if PBC_i==False and Corners == True:
        for j in range(0,N):
            for s in [2,3,4,5]:
                h[lat(0,j,s),lat(0,j,s)] = vv
                Nvv += 1
            for s in [0,1,2,5]:
                h[lat(N-1,j,s),lat(N-1,j,s)] = vv
                Nvv += 1

    h = np.conjugate(h.transpose()) + h
    return(h,Nvv)

folder = "output"
if not os.path.exists(folder):
    os.makedirs(folder)

t = 1000
s = 10
alph_max = 4
t2t0_max = 1

for n in range(0,s):
    p = round(alph_max*n**2/s**2,2)
    bigenergies = np.zeros((6*N**2, t,2))
    difference = np.zeros(t)
    for k in range(0,t):

        t0 = 1
        t1 = t0*p

        t2 = round(k*t2t0_max/t,3)
        t3 = t2*p
        M = 0

        print(f"{t*n + k}/{t*s}", end='\r')

        bigenergies[:,k,0] = t2/t0
        h,Nvv = initialize_hamiltonian(t0, t1, t2, t3, M)
        bigenergies[:,k,1] = np.linalg.eigvalsh(h)
        for i in range(0, len(bigenergies[:,k,1])):
            if bigenergies[i,k,1]>1000:
                bigenergies[i,k,1] = np.nan


        abs = np.unique(np.round(np.abs(bigenergies[:,k,1]),4))
        difference[k] = abs[0] - abs[1]


    # q = np.where(np.abs(difference) == np.amin(np.abs(difference)))
    #
    #
    # for i in range(0,len(q)):
    #     t0 = 1
    #     t1 = t0*p
    #
    #     t2 = round((q[i][0])*t2t0_max/t,3)
    #     t3 = t2*p
    #     M = 0
    #
    #     h,Nvv = initialize_hamiltonian(t0, t1, t2, t3, M)
    #     energies, waves = np.linalg.eigh(h)
    #     for i in range(0, len(energies)):
    #         if energies[i]>1000:
    #             energies[i] = np.nan
    #     energies = energies[~np.isnan(energies)]
    #     fig = plt.figure()
    #     plt.hist(energies,70)
    #     title = "t0:{}, t1:{}, t2:{}, t3:{}".format(t0,t1,t2,t3)
    #     fig.suptitle(title)
    #
    #     if PBC_i == False and PBC_j == False and Haldane == True:
    #         name = f"OBC and H Energy Spectrum: Alpha = {p}, t2/t0:{t2/t0}"
    #         newpath = f'output/OBCH_alpha{p}'
    #     if PBC_i == False and PBC_j == False and Haldane == False:
    #         name = f"OBC Energy Spectrum: Alpha = {p}, t2/t0:{t2/t0}"
    #         newpath = f'output/OBC_alpha{p}'
    #     if PBC_i == True and PBC_j == False and Haldane == True:
    #         name = f"Ribbon and H Energy Spectrum: Alpha = {p}, t2/t0:{t2/t0}"
    #         newpath = f'output/RibH_alpha{p}'
    #     if PBC_i == False and PBC_j == True and Haldane == True:
    #         name = f"Ribbon and H Energy Spectrum: Alpha = {p}, t2/t0:{t2/t0}"
    #         newpath = f'output/RibH_alpha{p}'
    #     if PBC_i == True and PBC_j == False and Haldane == False:
    #         name = f"Ribbon Energy Spectrum: Alpha = {p}, t2/t0:{t2/t0}"
    #         newpath = f'output/Rib_alpha{p}'
    #     if PBC_i == False and PBC_j == True and Haldane == False:
    #         name = f"Ribbon Energy Spectrum: Alpha = {p}, t2/t0:{t2/t0}"
    #         newpath = f'output/Rib_alpha{p}'
    #     if PBC_i == True and PBC_j == True and Haldane == True:
    #         name = f"PBC and H Energy Spectrum: Alpha = {p}, t2/t0:{t2/t0}"
    #         newpath = f'output/PBCH_alpha{p}'
    #     if PBC_i == True and PBC_j == True and Haldane == False:
    #         name = f"PBC Energy Spectrum: Alpha = {p}, t2/t0:{t2/t0}"
    #         newpath = f'output/PBC_alpha{p}'
    #
    #     if not os.path.exists(newpath):
    #         os.makedirs(newpath)
    #
    #     fig.savefig(f"{newpath}/spect2t0{t2/t0}_N{N}.pdf")
    #     plt.close(fig)
    #
    #     abs = np.unique(np.round(np.abs(energies),4))
    #
    #     if len(abs)<25:
    #         length = len(abs)
    #     else:
    #         length = 25
    #     for m in range(0,length):
    #
    #         mode = find_mode(energies,m)
    #         if len(mode)<=3:
    #             columns = len(mode)
    #             rows = 1
    #         elif 3 < len(mode) <= 6:
    #             columns = int(np.ceil(len(mode)/2))
    #             rows = 2
    #         else:
    #             columns = 3
    #             rows = 2
    #         fig, ax_array = plt.subplots(rows, columns,squeeze=False)
    #         count = 0
    #         for l, ax_row in enumerate(ax_array):
    #             for k,axes in enumerate(ax_row):
    #                 psi = np.transpose(waves)[mode[k]] #wavefunction
    #                 proba = (np.abs(psi))**2
    #                 proba = proba/np.max(proba)
    #
    #
    #                 axes.set_title(f"E: {np.round(energies[mode[k]],4)}, Mode:{m}.{count}", fontsize=10)
    #                 count +=1
    #
    #
    #                 cmap = matplotlib.cm.get_cmap('inferno')
    #                 normalize = matplotlib.colors.Normalize(vmin=min(proba), vmax=max(proba))
    #                 colors = [cmap(normalize(value)) for value in proba]
    #
    #
    #                 #plot the probability distribution:
    #                 x  = np.zeros(6*N*N)
    #                 y = np.zeros(6*N*N)
    #                 for i in range(N):
    #                     for j in range(N):
    #                         for l in range(6):
    #                             if h[lat(i,j,l),lat(i,j,l)] < 99:
    #                                 x[lat(i,j,l)] = pos(i,j,l)[0]
    #                                 y[lat(i,j,l)] = pos(i,j,l)[1]
    #                                 circle = Circle(pos(i,j,l),0.5,color=colors[lat(i,j,l)],alpha=1,ec=None,zorder=1)
    #                                 axes.add_artist(circle)
    #
    #                 axes.set_ylim(pos(0,N-1,3)[-1]-4,pos(N-1,0,0)[-1]+4)
    #                 axes.set_xlim(pos(0,0,5)[0]-4,pos(N-1,N-1,1)[0]+4)
    #                 axes.set_yticklabels([])
    #                 axes.set_xticklabels([])
    #                 axes.set_aspect('equal')
    #
    #                 plt.scatter(x,y,s=0, c=proba, cmap= 'inferno',vmin=min(proba), vmax=max(proba), facecolors='none')
    #                 plt.colorbar(ax=axes, use_gridspec=True)
    #
    #
    #             if PBC_i == False and PBC_j == False and Haldane == True:
    #                 name = f"OBC and H Eigenstate: Alpha = {p},  t2/t0:{t2/t0}"
    #                 newpath = f'output/OBCH_alpha{p}'
    #             if PBC_i == False and PBC_j == False and Haldane == False:
    #                 name = f"OBC Eigenstate: Alpha = {p},  t2/t0:{t2/t0}"
    #                 newpath = f'output/OBC_alpha{p}'
    #             if PBC_i == True and PBC_j == False and Haldane == True:
    #                 name = f"Ribbon and H Eigenstate: Alpha = {p},  t2/t0:{t2/t0}"
    #                 newpath = f'output/RibH_alpha{p}'
    #             if PBC_i == False and PBC_j == True and Haldane == True:
    #                 name = f"Ribbon and H Eigenstate: Alpha = {p}, t2/t0:{t2/t0}"
    #                 newpath = f'output/RibH_alpha{p}'
    #             if PBC_i == True and PBC_j == False and Haldane == False:
    #                 name = f"Ribbon Eigenstate: Alpha = {p}, t2/t0:{t2/t0}"
    #                 newpath = f'output/Rib_alpha{p}'
    #             if PBC_i == False and PBC_j == True and Haldane == False:
    #                 name = f"Ribbon Eigenstate: Alpha = {p}, t2/t0:{t2/t0}"
    #                 newpath = f'output/Rib_alpha{p}'
    #             if PBC_i == True and PBC_j == True and Haldane == True:
    #                 name = f"PBC and H Eigenstate: Alpha = {p}, t2/t0:{t2/t0}"
    #                 newpath = f'output/PBCH_alpha{p}'
    #             if PBC_i == True and PBC_j == True and Haldane == False:
    #                 name = f"PBC Eigenstate: Alpha = {p}, t2/t0:{t2/t0}"
    #                 newpath = f'output/PBC_alpha{p}'
    #
    #             if len(mode)>6:
    #                 plt.suptitle(f"First 6 {name}, Total States: {len(mode)}", fontsize = 10)
    #             else:
    #                 plt.suptitle(name)
    #
    #             if not os.path.exists(newpath):
    #                 os.makedirs(newpath)
    #
    #             file = f"{newpath}/eigt2t0{t2/t0}_N{N}_m{m}.pdf"
    #             fig.savefig(file)
    #             plt.close(fig)

    fig = plt.figure()
    for m in range(0,6*N*N):
        plt.plot(bigenergies[m,:,0], bigenergies[m,:,1], alpha=0.7, linewidth=0.1)

    plt.xlabel("t2/t0")
    plt.ylabel("E/t0")

    if PBC_i == False and PBC_j == False and Haldane == True:
        name = f"OBC and H Energy Spectrum: Alpha: {p}"
        newpath = f'output/OBCH_alpha{p}'
    if PBC_i == False and PBC_j == False and Haldane == False:
        name = f"OBC Energy Spectrum: Alpha: {p}"
        newpath = f'output/OBC_alpha{p}'
    if PBC_i == True and PBC_j == False and Haldane == True:
        name = f"Ribbon and H Energy Spectrum: Alpha: {p}"
        newpath = f'output/RibH_alpha{p}'
    if PBC_i == False and PBC_j == True and Haldane == True:
        name = f"Ribbon and H Energy Spectrum: Alpha: {p}"
        newpath = f'output/RibH_alpha{p}'
    if PBC_i == True and PBC_j == False and Haldane == False:
        name = f"Ribbon Energy Spectrum: Alpha: {p}"
        newpath = f'output/Rib_alpha{p}'
    if PBC_i == False and PBC_j == True and Haldane == False:
        name = f"Ribbon Energy Spectrum: Alpha: {p}"
        newpath = f'output/Rib_alpha{p}'
    if PBC_i == True and PBC_j == True and Haldane == True:
        name = f"PBC and H Energy Spectrum: Alpha: {p}"
        newpath = f'output/PBCH_alpha{p}'
    if PBC_i == True and PBC_j == True and Haldane == False:
        name = f"PBC Energy Spectrum: Alpha: {p}"
        newpath = f'output/PBC_alpha{p}'

    plt.title(name)
    fig.savefig(f"{newpath}.pdf")
    plt.close(fig)
